#version 450
#extension GL_GOOGLE_include_directive : enable
#include "global_ubo.glsl"

layout (quads, fractional_odd_spacing, ccw) in;

layout (location = 0) in vec3 fragPosWorld[];
layout (location = 1) in vec2 fragUV[];
layout (location = 2) in vec3 fragNormal[];
layout (location = 3) in vec3 fragTangent[];

layout (location = 0) out vec3 out_fragPosWorld;
layout (location = 1) out vec2 out_fragUV;
layout (location = 2) out vec3 out_fragNormal;
layout (location = 3) out vec3 out_fragTangent;

vec4 whs (float u){

float B0 = (1.-u)*(1.-u)*(1.-u);
	float B1 = 3.*u*(1.-u)*(1.-u);
	float B2 = 3.*u*u*(1.-u);
	float B3 = u*u*u;
return vec4(B0, B1, B2, B3);
}
vec3 bezier(vec2 uv, vec3 v0, vec3 v1, vec3 v2, vec3 v3)
{
	
	vec4 ub = whs(uv.s);
	vec4 vb = whs(uv.t);
	
	vec3 au = ub.x*v0 + ub.y*v1 + ub.z*v2 + ub.w*v3;
	vec3 av = vb.x*v0 + vb.y*v1 + vb.z*v2 + vb.w*v3;
	
	float weight = uv.s + uv.t;
	return (au * uv.s + av * uv.t) / weight;
} 

void main() {
    // get patch coordinate
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    // ----------------------------------------------------------------------
    // retrieve control point texture coordinates
    vec2 t00 = fragUV[0];
    vec2 t01 = fragUV[1];
    vec2 t10 = fragUV[2];
    vec2 t11 = fragUV[3];

    // bilinearly interpolate texture coordinate across patch
    vec2 t0 = (t01 - t00) * u + t00;
    vec2 t1 = (t11 - t10) * u + t10;
    out_fragUV = (t1 - t0) * v + t0;


    // ----------------------------------------------------------------------
    // retrieve control point position and normal coordinates
    vec3 n00 = fragNormal[0];
    vec3 n01 = fragNormal[1];
    vec3 n10 = fragNormal[2];
    vec3 n11 = fragNormal[3];

    // compute average normal
    vec3 n0 = (n01 - n00) * u + n00;
    vec3 n1 = (n11 - n10) * u + n10;
    out_fragNormal = normalize((n1 - n0) * v + n0);
	
	
    vec3 tg00 = fragTangent[0];
    vec3 tg01 = fragTangent[1];
    vec3 tg10 = fragTangent[2];
    vec3 tg11 = fragTangent[3];

    // compute average tangent
    vec3 tg0 = (tg01 - tg00) * u + tg00;
    vec3 tg1 = (tg11 - tg10) * u + tg10;
    out_fragTangent = normalize((tg1 - tg0) * v + tg0);
	
    vec3 p00 = gl_in[0].gl_Position.xyz;
    vec3 p01 = gl_in[1].gl_Position.xyz;
    vec3 p10 = gl_in[2].gl_Position.xyz;
    vec3 p11 = gl_in[3].gl_Position.xyz;
								   
    vec3 p = bezier(vec2(u, v), p00, p01, p10, p11);

	out_fragPosWorld = p;
    // ----------------------------------------------------------------------
    // output patch point position in clip space
    gl_Position = ubo.viewProjMatrix * vec4(p, 1.0);
}